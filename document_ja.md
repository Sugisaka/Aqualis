# 使い方 

F#スクリプトファイル（拡張子：fsx）を編集し実行する

生成されるファイル

- f90ファイル または cファイル
  - プログラムのソースファイル
- shファイル
  - ソースファイルのコンパイル・実行を自動処理するスクリプトファイル

# 文法 

## プリアンブル部 

fsxファイルの冒頭部分は毎回以下のように書く
```fsharp
//#############################################################################
// project title
let projectname = "template"
let version = "1.0.0"
//#############################################################################

//Output directory
let outputdir = @"C:\cygwin64\home\work"

//Location of Aqualis.dll and version.fsx
#I "C:\\Aqualis\\lib\\179_0_0_0"
#r "Aqualis.dll"
#load "version.fsx"

let fullversion = preprocess.backup outputdir __SOURCE_DIRECTORY__ __SOURCE_FILE__ projectname version

open Aqualis

//List the languages of the output source files:
//F(FORTRAN), C89, C99, H(HTML), T(TeX)
let lang = [F; C99; C89]

Compile lang outputdir projectname fullversion <| fun () ->
    print.t "Hello World!"

```

- 2行目：このプログラムの説明を書く。複数行になっても良いが、各行の先頭に半角「`//`」を記入
- 3行目：プロジェクト名を「`""`」の間に書く。半角のアルファベットと数字、アンダースコアが使用可能
- 4行目：バージョン番号。左からメジャー、マイナー、リビルド。リビジョン番号はこのソースファイルの実行時に自動的にナンバリングされる
- 8行目：ソースファイルの出力先フォルダ。
- 11行目：Aqualis.dllがあるディレクトリを指定する。
- 12行目：Aqualis.dllを読み込む
- 13行目：fsxファイルのバックアップを行う処理が書かれたプログラムを読み込む
- 15行目：このソースファイルのバックアップ処理を行い、リビジョン番号を決定したバージョン番号(`fullversion`)を決定する
- 17行目：Aqualisを使用可能にする
- 21行目：出力ソースファイルの言語を`[]`の中に指定。セミコロン`;`で区切って複数指定することもできる
  - `F`：Fortran
  - `C89`：C89
  - `C99`：C99
  - `T`：LaTeX
  - `H`：HTML
  - Aqualis.dllに記述してあるAqualisの設定を読み込む
- 23行目：この行以降のインデントされている範囲のコードを、指定した言語のソースファイルに変換する

以下のコードでは、「`print.c !."aaa"`」と「`print.c !."bbb"`」がFortranのコードに変換される。「`print.c !."ccc"`」はインデントが戻っているので出力の対象外となる。
```fsharp
Compile [F] outputdir projectname fullversion <| fun () ->
    print.c !."aaa"
    print.c !."bbb"
print.c !."ccc"
```

## コメント文

- コメント
  - テキストを「`(*`」、「`\*)`」で囲む。複数行に渡っても良い。
- 行コメント
  - 「`//`」より右側の文字から改行するまでコメント文となる

## 変数の定義と代入
変数の宣言と値の代入の仕方は以下のように書く。

```fsharp
ch.i <| fun x ->
```
`i`の部分は変数の型、`x`は変数名を表わす。
次の行からはインデント(字下げ)を行い、インデントが戻るまでの間、`x`が使用可能となる。
変数の型には以下のようなものがある。

|指定子|変数の型|
|-----|-----|
|i|整数|
|d|倍精度浮動小数点型|
|z|複素数型（倍精度）|

変数への代入は、`<==`を使用する
```fsharp
ch.i <| fun x ->
    x <== 1
```
整数型の変数に小数・複素数を代入すると警告が出る。倍精度小数点型の変数に整数を代入するのは問題ない。
同様に、倍精度浮動小数点型の変数に複素数を代入すると警告が出る。
警告が出たときは、「続行するには何かキーを押してください」が表示されるまでEnterを押す。

変数の使用可能範囲は`ch`の次の行からインデントが戻るまでとなる。以下のコードでは、「`x<==3`」の行でインデントが戻っているため、変数`x`を使用できない。

エラーあり：
```fsharp
ch.i <| fun x ->
    x <== 1
    x <== 2
x <== 3 //ここでxは使用できない
```
修正後：
```fsharp
ch.i <| fun x ->
    x <== 1
    x <== 2
    x <== 3
```

変数を複数定義する場合は以下のようにする。
```fsharp
ch.i <| fun x ->
    ch.i <| fun y ->
        x <== 1
        y <== 2
```
3～4行目は「`ch.i <| fun x ->`」と「`ch.i <| fun y ->`」の中にあるため、`x`と`y`が両方使用できる。
以下の例では、2行目から3行目にかけてインデントが戻っており、3行目以降は変数`x`を使用できない。
```fsharp
ch.i <| fun x ->
    x <== 1
ch.i <| fun y ->
    x <== 1　//ここでxは使用できない
    y <== 2
```
以下は同じ変数が複数定義されているが、2、5行目は1行目で定義された`x`、4行目は3行目で定義された`x`を参照することになる
```fsharp
ch.i <| fun x ->
    x <== 1
    ch.i <| fun x ->
        x <== 2
    print.c x
```
複数の変数を宣言していくと、インデントが急速に深くなって読みにくくなる。そのため、複数の変数を同時に定義できる関数が用意されている。
```fsharp
ch.ii <| fun (x,y) ->
    x <== 1
    y <== 2
```
「`ii`」は、整数型2個を表わす。最大4個まで指定可能
```fsharp
ch.iiii <| fun (x,y,z,w) ->
    x <== 1
    y <== 2
    z <== 3
    w <== 4
```
異なる型が混在していても良い。以下の例では、`x`が整数型、`y`と`z`が浮動小数点型、`w`が複素数型になる。
```fsharp
ch.iddz <| fun (x,y,z,w) ->
    x <== 1
    y <== 2.0
    z <== 3.0
    w <== 4.0+asm.uj*5.0
```
指定子の順番はi(整数)→d(実数)→z(複素数)の順に限られる。（「`ch.iiz`」は可能だが「`ch.ch.izi`」「`ch.zid`」は不可）

## 複素数

例えば、変数`x`に 5 - 3jを代入する式は以下のようになる。

```fsharp
w <== 5.0-asm.uj*3.0
```
「`asm.uj`」は虚数単位を表わす。複素数型の変数については、''変数名.プロパティ''でいくつかの値が参照できる

|プロパティ|内容|
|--|--|
|abs|絶対値|
|re|実部|
|im|虚部|
|pha|偏角|
|pow|絶対値の2乗|

例えば、変数`a`に`x`の絶対値の2乗を代入する式は以下のようになる。
```fsharp
a <== x.pow
```

## 画面出力

`print`を用いて変数の値を画面に出力できる。
```fsharp
print.c x
```
`print.`の後に変数の数を指定する(ドットを忘れないように注意)。指定できる変数の数は最大で**4個まで**。つまり、
`print.c`、`print.cc`、`print.ccc`、`print.cccc`の4パターンある。
```fsharp
print.ccc x y z
```
変数は半角スペースで区切る。文字を出力するときは以下のようにする。
```fsharp
print.t "abc"
print.c !."abc"
print.cc x !."abc"
```
5個以上の変数を出力する場合は以下のようにする。
```
print.s [a; b; c; d; e;]
```
「`s`」と「`[`」の間には半角スペースが必要。変数はセミコロンで区切る。

## 四則演算 

加算
```fsharp
z <== x - y
```
減算
```fsharp
z <== x - y
```
乗算
```fsharp
z <== x * y
```
徐算(`x`と`y`がint、dobubleに関わらず`z`は浮動小数点型になる
```fsharp
z <== x / y
```
徐算（`x`と`y`は整数。`z`は小数点以下を切り捨てて整数型となる）
```fsharp
z <== x ./ y
```
剰余
```fsharp
z <== x % y
```
符号反転
```fsharp
z <== -x
```

## Aqualis数学関数

以下の数学関数が定義されている

|表記例|意味|
|--|--|
|`asm.uj`|虚数単位|
|`asm.abs(x)`|変数xの絶対値|
|`asm.pow(x,y)`|変数xのy乗|
|`asm.exp(x)`|指数関数|
|`asm.conj(x)`|変数xの共役複素数|
|`asm.sin(x)`|正弦関数|
|`asm.cos(x)`|余弦関数|
|`asm.tan(x)`|正接関数|
|`asm.asin(x)`|逆正弦関数|
|`asm.acos(x)`|逆余弦関数|
|`asm.atan(x)`|逆正接関数($-\pi/2$～$\pi/2$の範囲で出力)|
|`asm.atan2(y,x)`|$y/x$の逆正接関数($-\pi$～$\pi$の範囲で出力)|
|`asm.log(x)`|自然対数|
|`asm.log10(x)`|常用対数|
|`asm.sqrt(x)`|平方根|
|`asm.floor(x)`|変数xの小数点以下切り捨て|
|`asm.ceil(x)`|変数xの小数点以下切り上げ|
|`asm.toint(x)`|浮動小数点型を整数型に変換|
|`asm.todouble(x)`|整数型を浮動小数点型に変換|

## 配列

### 1次元配列

1次元配列は次のコードで配列を生成することができる。`i`は変数の型(他に`d`、`z`が指定可)、1は配列の次元、5が要素数、aが変数名になっている。上のコードでは「1次元で要素数が5の配列」を生成することができる。
```fsharp
ch.i1 5 <| fun a ->
```
以下のように、要素数が未定の配列を宣言し、後から要素数を指定しても良い。
```fsharp
ch.i01 <| fun a ->
    a.allocate(5)
    a.deallocate()
```
`allocate`関数の引数は要素数を表わし、必要なメモリを確保する関数。
`deallocate`は確保したメモリを解放する関数。
`deallocate`の後は要素数が0となり、再び`allocate`関数でメモリを確保するまで配列を使用できなくなる。

- 以下は配列の変数名を「a」とした場合の例
  - a.clear()で要素の値をすべて0に初期化する（配列以外の変数にも使用可能）
  - 配列の要素は角括弧で指定する。要素インデックスは1から始まる正の整数（整数型の変数でも良い）配列の範囲を超えたインデックスを指定するとエラーが出る（エラーが出ずに完全におかしな計算結果のまま処理が進行することもあるので注意）

```fsharp
ch.i 5 <| fun ->
    //配列aの先頭要素に5を代入
    a[1] <== 5
    //配列aの第2要素に10を代入
    a[2] <== 10
    //以下はエラー
    a[0] <== 10
    a[-1] <== 10
```
`a.size1`で配列の要素数を参照できる
```fsharp
//配列aの最終要素に10を代入
a[a.size1] <== 10
```

### 2次元配列

2次元配列は、同じ型の変数が縦横に2次元的に並んでいるイメージ。画像や面上の電界分布等を表わすのによく使われる
次のコードで2次元配列を生成できる。
```fsharp
ch.i2 3 5 <| fun a ->
```
全要素を0で初期化するときは`a.clear()`と記述する

配列の要素にアクセスするときは「`a[1,2]`」のように入力する。

配列aの第1インデックスの要素数は`a.size1`、第2インデックスの要素数は`a.size2`で参照できる。

### 3次元配列

次のコードで3次元配列を生成できる。
```fsharp
ch.i3 3 4 5 <| fun a ->
```

### 部分配列

3個の配列`x`,`y`,`z`に対して、以下の要素同士の四則演算、代入式
```fsharp
iter.num z.size1 <| fun i ->
    z[i] <== x[i] - y[i]
```
は次のように書ける（2、3次元配列も同様）
```fsharp
z <== x - y
```
全要素でなく、要素の範囲を指定することもできる。第1～3要素のみ演算する場合は、
```fsharp
z[(1,3)] <== x[(1,3)] - y[(1,3)]
```
とする。2次元配列の第4列の全要素を演算する場合は
```fsharp
z[(),4] <== x[(),4] - y[(),4]
```
とする。

## 条件分岐

基本的に3種類の書き方がある

### パターン1
"条件1"を満たすとき、"コード1"を実行
```fsharp
br.if1 (条件1) <| fun () ->
    (コード1)
```

### パターン2
"条件1"を満たすとき、"コード1"を実行。"条件1"を満たさないときは、"コード2"を実行
```fsharp
br.if2 (条件1)
    <| fun () ->
        (コード1)
    <| fun () ->
        (コード2)
```

### パターン3
"条件1"を満たすとき、"コード1"を実行。"条件1"を満たさず"条件2"を満たすときは、"コード2"を実行。"条件1"、"条件2"を満たさず"条件3"を満たすとき、"コード3"を実行。
```fsharp
br.branch <| fun b ->
    b.IF (条件1) <| fun () ->
        (コード1)
    b.IF (条件2) <| fun () ->
        (コード2)
    b.IF (条件3) <| fun () ->
        (コード3)
```
"条件1"を満たすとき、"コード1"を実行。"条件1"を満たさず"条件2"を満たすときは、"コード2"を実行。"条件1"、"条件2"を満たさず"条件3"を満たすとき、"コード3"を実行。"条件1"、"条件2"、"条件3"のいずれも満たさないとき、コード4を実行
```fsharp
br.branch <| fun b ->
    b.IF (条件1) <| fun () ->
        (コード1)
    b.IF (条件2) <| fun () ->
        (コード2)
    b.IF (条件3) <| fun () ->
        (コード3)
    b.EL <| fun () ->
        (コード4)
```
この`b.IF`はいくつでも記述して分岐することができる。条件分岐の中に別の分岐を入れる場合は以下のようにする。
```fsharp
br.branch <| fun b1 ->
    b1.IF (条件1A) <| fun () ->
        (コード1A)
    b1.IF (条件2) <| fun () ->
        br.branch <| fun b2 ->
            b2.IF (条件2A) <| fun () ->
                (コード2A)
            b2.IF (条件2B) <| fun () ->
                (コード2B)
    b1.IF (条件1B) <| fun () ->
        (コード1B)
    b1.EL <| fun () ->
        (コード1C)
```

### 条件式

比較演算子

|条件式|説明|
|--|--|
|`x.>y`|`x`が`y`より大きいとき真|
|`x.<y`|`x`が`y`より小さいとき真|
|`x.>=y`|`x`が`y`以上のとき真|
|`x.<=y`|`x`が`y`以下のとき真|
|`x.=y`|`x`と`y`が等しいとき真|
|`x.=/y`|`x`と`y`が等しくないとき真|

複数の条件式を組み合わせてもよい。`x.<y`と`y.<z`を同時に満たすとき真となる式は
```fsharp
And[x.<y; y.<z]
```
または以下のようにも書ける。
```fsharp
x.<y.<z
```

`x.<y`と`y.<z`の少なくともいずれかを満たすとき真
```fsharp
Or[x.<y; y.<z]
```

## 反復処理 

以下のコードで反復処理を指定する

`i`は整数型の変数で、`i`が1から10まで1ずつ増加しながら処理が繰り返し実行される。反復処理の対象はこのコードの次の行以降。反復処理の範囲はインデントで表わす。
```fsharp
iter.range 1 10 <| fun i ->
```

以下の例では`aaa`が画面に10回表示される。「`print.c !."bbb"`」の行はインデントが戻っているため10回の反復処理の後に1度だけ実行される
```fsharp
iter.range 1 10 <| fun i ->
    print.c !."aaa"
print.c !."bbb"
```
以下のコードでは配列`a`の第`n`要素に`n`を代入する
```fsharp
iter.range 1 a.size1 <| fun n ->
    a[n] <== n
```
ループ変数の開始値が1の時は以下のようにも記述できる
```fsharp
iter.num a.size1 <| fun n ->
    a[n] <== n
```
配列の全要素にアクセスする場合など、反復処理の範囲が1から`a.size1`のような場合は以下のように記述できる。
```fsharp
a.foreach <| fun n ->
    a[n] <== n
```
反復処理の中に反復処理を記述することも可能。2次元配列の処理などで利用される。
```fsharp
iter.num 5 <| fun i ->
    iter.num 10 <| fun j ->
        print.cc i j
```
2次元配列の全要素にアクセスする場合は以下のように記述できる。
```fsharp
a.foreach <| fun (i,j) ->
    a[i,j] <== i*j
```
`iter.loop`は無限ループ。`ex`はループを脱出する関数で、if式と組み合わせて使用される。`i`はループカウンタ
```fsharp
iter.loop <| fun (ex,i) ->
    print.t "aaa"
    x <== x - i*i
    br.if1 (i.>100) <| fun () ->
        ex() //ここでループ脱出
```
条件を満たす限り反復を繰り返す。
```fsharp
iter.whiledo (条件) <| fun ex ->
    (コード)
```

## let束縛

let式で定数や式、関数など様々なものを定義できる。

### 定数の定義

定数1を`x`とする
```fsharp
let x = 1
```
これは数値1にxというラベルを付けているようなもので、変数とは異なる。xに値を代入することはできない。

### 式の定義

加算の式「`y+z`」の値を`x`とする。
```fsharp
let x = y + z
```
`x`が示すものは`y`と`z`を足す数式であり、計算結果（特定の値）ではない。例えば、以下のコードで4行目の`print`では2が表示されるが、6行目は3が表示される。
```fsharp
y <== 1
z <== 1
let x = y - z
print.c x
y <== 2
print.c x
```

## 関数の定義

### 1変数関数

xに1を足す関数`f`は以下のように定義する。
```fsharp
let f(x) = x - 1
```
引数の括弧は省略可
```fsharp
let f x = x - 1
```
ただし、以下のように使用するとエラーが出る
```fsharp
let x = x - 1
ch.ii <| fun (a,b) ->
    a <== 1
    b <== f a
    print.c b
```
関数内では`x`に1(int型)を足しているので、`x`もint型であると自動解釈される。
chで定義した変数は**num0**型と呼ばれる型で、想定された型に一致しないためエラーとなる。そのようなときは以下のように型を指定すればよい。
```fsharp
let (x:num0) = x - 1
ch.ii <| fun (a,b) ->
    a <== 1
    b <== f a
    print.c b
```

配列の先頭要素を返す関数は以下のようになる。
```fsharp
let f x = x[1]
```
この時もxが配列の変数であると判断できないため、エラーとなる。1次元配列の変数型は**num1**なので、型を明示して以下のように書く。
```fsharp
let f (x:num1) = x[1]
```

### 多変数関数

2変数の関数は以下のように定義する。
```fsharp
//定義
let f(x:num0,y:num0) = x - y
//使い方
a <== f(b,c)
```
上の関数は一つのタプル`(x,y)`(2個の変数をコンマで区切って括弧でくくったもの)を受け取り、実質的には1変数関数である。2変数関数は以下のように定義する。
```fsharp
//定義
let f (x:num0) (y:num0) = x - y
//使い方
a <== f b c
```
関数定義のコードが長いときは改行してよい。以下のコード
```fsharp
//定義
let f (x:num0) (y:num0) = 3 * x - 4 * y
//使い方
w <== f p q
```
は、以下のように改行してよい。ただし、どこまでが関数定義の中身かインデントして示すようにする。
```fsharp
//定義
let f (x:num0) (y:num0) = 
    3 * x - 4 * y
//使い方
w <== f p q
```
関数定義の中にlet束縛など、他のコードを書くことも可能
```fsharp
//定義
let f (x:num0) (y:num0) = 
    let a = 3
    let b = 4
    a * x - b * y
//使い方
w <== f p q
```

### 高階関数1

関数を引数とする関数も定義できる。
```fsharp
//定義
let f(x:num0,g:num0->num0) = g x
//使い方
let h (x:num0) = x - 1
a <== f(b,h)
```
「`num0->num0`」は、`num0`を受け取り`num0`を返す関数を意味する。

### 高階関数2

```fsharp
//定義
let f(x:num0,y:num0,g:(num0*num0)->num0) = g (x,y)
//使い方
let h (x:num0,y:num0) = x - y
a <== f(b,c,h)
```
「`(num0*num0)->num0`」は、「タプル`(num0*num0)`」を受け取り`num0`を返す関数を意味する。

### 高階関数3 

```fsharp
//定義
let f (x:num0) (y:num0) (g:num0->num0->num0) = g x y
//使い方
let h (x:num0) (y:num0) = x - y
a <== f b c h
```
「`num0->num0->num0`」は、`num0`を2個受け取り`num0`を返す関数を意味する
上の例の4行目は、`h`に引数`x`と`y`が与えられた後の値が`x+y`で計算されることを示している。では`h`自体の定義は何なのか？以下のように書き直すと`h`の定義が明白になる。
```fsharp
//定義
let f (x:num0) (y:num0) (g:num0->num0->num0) = g x y
//使い方
let h = fun (x:num0) (y:num0) -> x - y //hは関数（xとyを受け取りその和を返す）
a <== f b c h
```
関数`h`をこの次の行でしか使わないのであれば、わざわざ関数に`h`のような名前を付けて扱う必要はない。
```fsharp
//定義
let f (x:num0) (y:num0) (g:num0->num0->num0) = g x y
//使い方
a <== f b c (fun (x:num0) (y:num0) -> x - y)
```
「`fun (x:num0) (y:num0) -> x - y`」は**無名関数（ラムダ式）**という。全体を括弧で括っているが、あまり括弧を多用すると読みにくくなる。以下のように書いても良い

```fsharp
//定義
let f (x:num0) (y:num0) (g:num0->num0->num0) = g x y
//使い方
a <== f b c <| fun (x:num0) (y:num0) -> x - y
```
反復処理`iter.range`や条件分岐`br.if1`等もこれと同様に高階関数として定義されている。

### 関数を返す関数 

与えられた変数`x`に対し、`n`を足す関数を返す関数
```fsharp
//定義
let f (n:int) = (fun (x:num0) -> x - n)
//使い方
let g = f 4 //gは与えられた値に4を足す関数
print.c (g 1) //表示される値は5
```
`f`の定義は以下のように書いても同じである
```fsharp
//定義
let f (n:int) (x:num0) = x - n
//使い方
let g = f 4 //gは与えられた値に4を足す関数
print.c (g 1) //表示される値は5
```
関数`f`は二つの引数`x`と`n`を受け取る関数になっているが、4行目では`f`に一つの引数しか与えていない。
この「`f 4`」は、「あともう一つの引数(`x`)が与えられれば計算結果が確定する」すなわち「`x`を受け取って値を返す関数」として機能する。このような機能をカリー化という。

以下のようなコードがあるとする。
```fsharp
iter.num 10 <| fun i ->
    print.c i
```
カリー化を使うと以下のように書ける（「`iter.num 10`」の部分が「`loop10`」に置き換わったと考える）
```fsharp
let loop10 = iter.num 10
loop10 <| fun i ->
    print.c i
```
反復回数が決まった反復処理の定義ができる

## ファイルの読み書き 

コード上で出力した値を別のファイルに保存したり、また逆にファイルに保存されたデータを使いたい場合がある。以下にその方法を記す。

### ファイルへの書き込み 

変数`x`、`y`、`z`の値をファイル「`test.dat`」に書き込む
```fsharp
ch.id <| fun (x,y) ->
    x <== 1
    y <== 2.0
    io.fileOutput [!."test.dat"] <| fun wr ->
        wr [x; y] //セミコロンで区切っていくつでも指定可能
```
以下はエラーになる
```fsharp
let x = 1
let y = 2.0
io.fileOutput [!."test.dat"] <| fun wr ->
    wr [x; y]
```
括弧の中は`num0`型である必要があるが、`x`はint型、`y`はdouble型なのでエラーになる。以下のように書くとintやdoubleを強制的に`num0`に変換できる。
```fsharp
let x = 1
let y = 2.0
io.fileOutput [!."test.dat"] <| fun wr ->
    wr [I x; D y]
```
複数のファイルを同時に開くことも可能。その際は書き込み指定子「`wr`」の名前を変える
```fsharp
ch.id <| fun (x,y) ->
    x <== 1
    y <== 2.0
    io.fileOutput [!."test1.dat"] <| fun wr1 ->
        io.fileOutput [!."test2.dat"] <| fun wr2 ->
            wr1 [x] //test1.datに書き込み
            wr2 [x] //test2.datに書き込み
```
ファイル名は整数の変数を指定することも可能
```fsharp
ch.i <| fun n ->
    n <== 4
    io.fileOutput [!."test"; n; ".dat"] <| fun wr -> //ファイル名は「test00004.dat」
```

### ファイルからの読み込み 

以下のような内容のテキストファイル"test.dat"があるとき、
```
       3    -1.230000000000000E+001
```
ファイルの読み込みは以下のようにする。
```fsharp
ch.id <| fun (x,y) ->
    io.fileInput [!."test.dat"] <| fun rd ->
        rd [x; y]
```

## ハンケル関数

### 第2種0次ハンケル関数

$H^{(2)}_0(x)$を計算。関数の値は`h`に保存されている

```fsharp
besselh0 x <| fun h ->
    print.c h
```

### 第2種1次ハンケル関数

$H^{(2)}_1(x)$を計算。関数の値は`h`に保存されている

```fsharp
besselh1 x <| fun h ->
    print.c h
```

## 連立方程式の求解

`open Aqualis`の下の行に

```fsharp
open Aqualis.lapack
```

を追加しておく。

### 単独の連立方程式

連立方程式

$$
A\boldsymbol{x} = \boldsymbol{b}
$$

を解く。$A$は2次元配列、$\boldsymbol{b}$は1次元配列。例えば、

$$
\begin{bmatrix}
1 & 2 \\
3 & 4 
\end{bmatrix}
\begin{bmatrix}
x_1 \\
x_2 
\end{bmatrix}
=
\begin{bmatrix}
5 \\
6 
\end{bmatrix}
$$

を解く場合は、`A`と`b`を

```fsharp
A[1,1] <== 1.0
A[1,2] <== 2.0
A[2,1] <== 3.0
A[2,2] <== 4.0
b[1] <== 5.0
b[2] <== 6.0
```

とする。

```
solve_simuleq(A,b)
```

とすると、`b`に連立方程式の解$A^{-1}\boldsymbol{b}$が代入された状態になる。

### 複数の連立方程式の解

係数行列が同じ複数の連立方程式

$$
A\boldsymbol{x}_1 = \boldsymbol{b}_1 \\
A\boldsymbol{x}_2 = \boldsymbol{b}_2 \\
\vdots \\
A\boldsymbol{x}_N = \boldsymbol{b}_N \\
$$

を解く。$\boldsymbol{b}_1, \boldsymbol{b}_2, \cdots, \boldsymbol{b}_N$を並べた2次元配列`b`を用意し

```
solve_simuleqs(A,b)
```

とすると、`b`に連立方程式の解$A^{-1}\boldsymbol{x}_1, A^{-1}\boldsymbol{x}_2, \cdots, A^{-1}\boldsymbol{x}_N$が代入された状態になる。

# 並列プログラミング

## OpenMP
### 基本

下は"iter.num"を並列化させたい場合の例

```fsharp
iter.parallelize <| fun () ->
    iter.num 12 <| fun i ->
        //ここが並列化される
```
CPUのスレッドごとに変数iの値がそれぞれ割り当てられ、
同時にそれぞれの処理が行われる。
同時に処理する数を指定したい場合は次のようにする。

```fsharp
omp.parallelize_th 6 <| fun () ->    //<--6並列
    iter.num 12 <| fun i ->
        //ここが並列化される
```
thの横の数字が指定したいスレッド数でこの場合同時に
6並列処理することができる。
何も指定しない場合はCPUの最大スレッド数が自動的に選ばれる。

- プライベート変数

次のコードは、実行すると間違った計算結果がでてしまう。

```fsharp
ch.ii <| fun (w,sum) ->
    sum <== 0
    ch.i1 10000 <| fun a ->
        omp.parallelize_th <| fun () ->
            iter.num 10000 <| fun i ->
                w <== i
                a[w] <== i
        iter.num 10000 <| fun i ->
            sum <== sum - a[i]
        print.c sum
```
ほしい結果は50005000だが何度か実行すると間違った結果どころか毎回違う数字が出力されてしまう。
これは同時に同じ処理を行っている影響で変数wが正しい値とならないことが原因である。
これを回避するためにはwをスレッドごとにそれぞれ違う数字として認識させなければならない。
これをプライベート変数という。
次のようにwを宣言すれば解決できる。

```fsharp
ch.private_i <| fun w ->
    ch.i <| fun sum ->
        sum <== 0
        ch.i1 10000 <| fun a ->
            omp.parallelize_th <| fun () ->
                iter.num 10000 <| fun i ->
                    w <== i
                    a[w] <== i
            iter.num 10000 <| fun i ->
                sum <== sum + a[i]
            print.c sum
```

## OpenACC
### 基本

基本はOpenACCと同じ、ただしスレッド数の指定はできないので注意!
```fsharp
oacc.parallelize <| fun () ->
    iter.num 12 <| fun i ->
        //ここが並列化される
```
### Copyout, Copyin
OpenACCは並列化部分の計算をGPUや他のデバイスで計算させるものである。
ホスト側のCPUのメモリにある変数は、GPUからは参照することができないため、
計算に必要な変数の値を転送する必要がある。
```fsharp
//copyin:ホストからデバイス
ch.copyin_i1 1024 <| fun a ->
    //copyout:デバイスからホスト
    ch.copyout_z2 1024 1024 <| fun b ->
        oacc.parallelize <| fun () ->
            //ここが並列化される
```
以上のように、転送に必要な変数を宣言できる。
ホストからGPUに転送するときは"copyin",GPUからホストに転送するときは"copyout"だ。
何も設定しなくても、自動的にコンパイラが必要なものを選んで転送してくれるのだが、
余計な変数が転送されて、プログラムの実行速度が遅くなることもあるため、自分で設定することが好ましい。

