/*=============================================================================================*/
/* Project name: test0 */
/* Project version: bbb */
/*---------------------------------------------------------------------------------------------*/
/* Generated by Aqualis (algorithm and equation analyzer for lightwave simulation) */
/* Aqualis version: aaa */
/* Generated date: 2023/10/21 16:14:10 */
/*=============================================================================================*/
#include <stdio.h>
#include <stdlib.h>
#include <complex.h>
#include <math.h>
#undef I
#define uj _Complex_I
double pi=3.14159265358979;
double y;
double x;
int ic001;
int ic002;
double d001;
double *d1001;
int d1001_size[1]={-1};
double complex *z2001;
int z2001_size[2]={-1,-1};
int main()
{
  x = pi;
  y = 1;
  d1001_size[0] = 10;
  d1001=(double *)malloc(sizeof(double)*d1001_size[0]);
  z2001_size[0] = 10;
  z2001_size[1] = 20;
  z2001=(double complex *)malloc(sizeof(double complex)*z2001_size[0]*z2001_size[1]);
  d001 = sin(x);
  for(ic001=1; ic001<=d1001_size[0]; ic001++)
  {
    d1001[ic001-1] = d1001[ic001-1]/(double)(d1001_size[0]);
  }
  for(ic001=1; ic001<=z2001_size[0]; ic001++)
  {
    for(ic002=1; ic002<=z2001_size[1]; ic002++)
    {
      z2001[(ic002-1)*z2001_size[0]+ic001-1] = z2001[(ic002-1)*z2001_size[0]+ic001-1]/((double)(z2001_size[0])*(double)(z2001_size[1]));
      z2001[(ic002-1)*z2001_size[0]+ic001-1] = (z2001[(ic002-1)*z2001_size[0]+ic001-1]+x*d001/y)/((double)(z2001_size[0])*(double)(z2001_size[1]));
    }
  }
  z2001_size[0] = -1;
  free(z2001);
  d1001_size[0] = -1;
  free(d1001);
  return 0;
}
